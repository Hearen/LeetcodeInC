Thu Sep  1 11:27:36 CST 2016

By LHearen

 - [Perfect Squares](http://lhearen.top/2016/09/01/Perfect-Squares/)
 - [Counting Bits](http://lhearen.top/2016/09/01/Counting-Bits/)
 - [Interleaving String](http://lhearen.top/2016/09/01/Interleaving-String/)
 - [Scramble String](http://lhearen.top/2016/09/01/Scramble-String/)
 - [Distinct Subsequences](http://lhearen.top/2016/09/01/Distinct-Subsequences/)

### Perfect Squares
Given a positive integer n, find the least number of perfect square numbers (for example, 1, 4, 9, 16, ...) which sum to n.

> For example, given n = 12, return 3 because 12 = 4 + 4 + 4; given n = 13, return 2 because 13 = 4 + 9.

### Solution
#### Math 
If you don't know Lagrange's four-square theorem, please check [wiki](https://en.wikipedia.org/wiki/Lagrange%27s_four-square_theorem) first. In a summary, it's all about that the maximum will be 4 and in that case  it will follow the following equation, otherwise it will be 1, 2, 3.

>  4^k(8m+7)

```
int numSquares(int n) {
	while(!(n&3)) n >>= 2;
	if(n%8 == 7) return 4;
	for(int a = sqrt(n); a > 0; --a) {
		int b = sqrt(n-a*a);
		if(a*a+b*b == n) return b? 2:1;
	}
	return 3;
}
```

> **Note** If 2m = a^2+b^2 then m=x^2+y^2 which is proved [here](http://planetmath.org/proofoflagrangesfoursquaretheorem). So while(!(n&3)) n /= 4; will not affect the final result but accelerate it.

#### Static DP

```
int numSquares(int n) {
	static vector<int> v{0, 1};
	int a = 0, b = 0, t = 0;
	while(v.size() <= n) {
		a = t = v.size();
		for(int i = sqrt(a); i > 0; --i) {
			b = a-i*i;
			t = min(t, !b? 1 : 1+v[b]);
		}
		v.push_back(t);
	}
	return v[n];
}
```

### Counting Bits
Given a non negative integer number num. For every numbers i in the range 0 ≤ i ≤ num calculate the number of 1's in their binary representation and return them as an array.

> Example:
For num = 5 you should return [0,1,1,2,1,2].


### Solution

```
class Solution {
public:
    vector<int> countBits(int num) {
        vector<int> v(1,0);
        for(int i = 1; i <= num; ++i)
            v.push_back(v[i>>1]+(i&1));
        return v;
    }
};
```

### Interleaving String
Given s1, s2, s3, find whether s3 is formed by the interleaving of s1 and s2.

> For example, Given: s1 = "aabcc",
When s3 = "aadbbcbcac", return true.
When s3 = "aadbbbaccc", return false.

### Solution

```
bool isInterleave(string s1, string s2, string s3) {
    int len1 = s1.length(), len2 = s2.length(), len3 = s3.length();
    if(len1+len2 != len3) return false;
    if(len3 == 0) return true;
    int i = 0, *cur = new int[len2+1]();
    cur[0] = 1; 
    while(s2[i] == s3[i]) cur[++i] = 1; //corner case;
    for(i = 1; i <= len1; ++i)
        for(int j = 0; j <= len2; ++j)
            cur[j] = (j>0 && cur[j-1] && s2[j-1]==s3[i+j-1]) || //s2 matches s3;
                (cur[j] && s1[i-1]==s3[i+j-1]); //s1 matches s3;
    bool ret = cur[len2];
    delete [] cur;
    return ret;
}
```

### Scramble String
Given a string s1, we may represent it as a binary tree by partitioning it to two non-empty substrings recursively.

Below is one possible representation of s1 = "great":
```
    great
   /    \
  gr    eat
 / \    /  \
g   r  e   at
           / \
          a   t
```
To scramble the string, we may choose any non-leaf node and swap its two children.

For example, if we choose the node "gr" and swap its two children, it produces a scrambled string "rgeat".
```
    rgeat
   /    \
  rg    eat
 / \    /  \
r   g  e   at
           / \
          a   t
```
We say that "rgeat" is a scrambled string of "great".

Similarly, if we continue to swap the children of nodes "eat" and "at", it produces a scrambled string "rgtae".
```
    rgtae
   /    \
  rg    tae
 / \    /  \
r   g  ta  e
       / \
      t   a
```
We say that "rgtae" is a scrambled string of "great".

Given two strings s1 and s2 of the same length, determine if s2 is a scrambled string of s1.

### Solution

#### DP

> **Note** match[size][index1][index2] the size is the comparing size of the two strings, index1 is the start index of string 1 and index2 is that of string 2.
```
bool isScramble(string s1, string s2){
    int len = s1.length();
    if(!len) return true;
    if(len==1) return s1==s2;
    vector<vector<vector<bool>>> match(len+1, vector<vector<bool>>(len, vector<bool>(len, false)));
    for(int i = 0; i < len; i++)
        for(int j = 0; j < len; j++)
            match[1][i][j] = (s1[i] == s2[j]);
    for(int d = 2; d <= len; d++)
        for(int i = 0; i <= len-d; i++)
            for(int j = 0; j <= len-d; j++)
                for(int k = 1; k<d && !match[d][i][j]; k++)
                    match[d][i][j] = (match[k][i][j] && match[d-k][i+k][j+k]) || (match[k][i+d-k][j] && match[d-k][i][j+k]);
    return match[len][0][0];
}
```

#### Trick

> **Note** the pruning technique here is very efficient and impressive.

```
class Solution {
public:
    bool isnScramble(char* s1, char* s2, int len) {
    if(!strncmp(s1, s2, len)) return true;
    int count[26] = {0};
    for(int i = 0; i < len; i++) count[s1[i]-'a']++, count[s2[i]-'a']--;
    for(int i = 0; i < 26; i++) if(count[i]) return false;
    for(int i=1; i < len; i++)
        if((isnScramble(s1, s2, i) && isnScramble(s1+i, s2+i, len-i)) ||
                (isnScramble(s1, s2+len-i, i) && isnScramble(s1+i, s2, len-i))) return true;
    return false;
    }

    bool isScramble(string s1, string s2) {
        return isnScramble((char*)s1.c_str(), (char*)s2.c_str(), s1.length());
    }
};
```

### Distinct Subsequences
Given a string S and a string T, count the number of distinct subsequences of T in S.

A subsequence of a string is a new string which is formed from the original string by deleting some (can be none) of the characters without disturbing the relative positions of the remaining characters. (ie, "ACE" is a subsequence of "ABCDE" while "AEC" is not).

> Here is an example:
S = "rabbbit", T = "rabbit" 
Return 3.

### Solution
`cur` is storing the `maximal` amount of subsequence `t` in `s` so far, if it's not overwritten, it will always the value of `previous` loop. So here is the thing, if `s[i-1]==t[j-1]`:

- ignore s[i-1] then it will be `cur[j]` (the maximal amount of `t[0...i-1]` in s[0...i-2])
- take the s[i-1] in then it will be `cur[j-1]` (the maximal amount of `t[0...i-2]` in s[0...i-2])

Since `s[i-1]==t[i-1]`, then there will be both cases so we have to add them up for it.

```
class Solution {
public:
    int numDistinct(string s, string t) {
        int tLen = t.length(), *cur = new int[tLen+1]();
        cur[0] = 1;
        for(int i = 1; i <= s.length(); ++i)
            for(int j = tLen; j > 0; --j)
                if(s[i-1] == t[j-1]) cur[j] += cur[j-1];
        int ret = cur[tLen];
        delete [] cur;
        return ret;
    }
};
```
