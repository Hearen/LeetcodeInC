Mon Sep 12 15:24:20 CST 2016

By LHearen

 - [Mod of Big Integer](http://lhearen.top/2016/08/30/Mod-of-Big-Integer/)
 - [Integer Break](http://lhearen.top/2016/09/01/Integer-Break/)
 - [Making Polygons](http://lhearen.top/2016/08/10/Making-Polygons/)
 - [Expression Add Operators](http://lhearen.top/2016/07/13/Expression-Add-Operators/)
 - [Multiply Strings](http://lhearen.top/2016/09/12/Multiply-Strings/)
 - [Rectangle Area](http://lhearen.top/2016/07/06/Math/)
 - [Super Ugly Number](http://lhearen.top/2016/07/06/Math/)
 - [Bulb Switcher](http://lhearen.top/2016/09/12/Bulb-Switcher/)
 - [Self Crossing](http://lhearen.top/2016/09/12/Self-Crossing/)
 - [Water and Jug Problem](http://lhearen.top/2016/07/06/Math/)
 - [Sqrt implementation](http://lhearen.top/2016/07/06/Math/)
 - [Count Numbers with Unique Digits](http://lhearen.top/2016/07/06/Math/)
 - [Power of Three](http://lhearen.top/2016/07/06/Math/)
 - [Super Ugly Number](http://lhearen.top/2016/07/06/Math/)
 - [Integer to English Words](http://lhearen.top/2016/07/06/Math/)
 - [Add Digits](http://lhearen.top/2016/07/06/Math/)
 - [Number of Digit One](http://lhearen.top/2016/07/06/Math/)
 - [Basic Calculator](http://lhearen.top/2016/07/06/Math/)
 - [Rectangle Area](http://lhearen.top/2016/07/06/Math/)
 - [Factorial Trailing Zeroes](http://lhearen.top/2016/07/06/Math/)
 - [Happy Number](http://lhearen.top/2016/07/06/Math/)
 - [Count Primes](http://lhearen.top/2016/07/06/Math/)
 - [Excel Sheet Column Title](http://lhearen.top/2016/07/06/Math/)
 - [Fraction to Recurring Decimal](http://lhearen.top/2016/07/06/Math/)
 - [String to Integer (atoi)](http://lhearen.top/2016/07/06/Math/)
 - [Integer to Roman](http://lhearen.top/2016/07/06/Math/)
 - [Roman to Integer](http://lhearen.top/2016/07/06/Math/)
 - [Divide Two Integers](http://lhearen.top/2016/07/06/Math/)
 - [Add Binary](http://lhearen.top/2016/07/06/Math/)
 - [Palindrome Number](http://lhearen.top/2016/07/06/Math/)
 - [Valid Number](http://lhearen.top/2016/07/06/Math/)
 - [Pow(x, n)](http://lhearen.top/2016/07/06/Math/)
 - [Permutation Sequence](http://lhearen.top/2016/07/06/Math/)
 - [Max Points on a Line](http://lhearen.top/2016/07/06/Math/)
 - [Finding nth Finobacci number in O(log n)](http://lhearen.top/2016/07/06/Math/)
 - [Combinatorics](http://lhearen.top/2016/07/06/Math/)
 - [Integer Replacement](http://lhearen.top/2016/09/12/Integer-Replacement/)
 - [Strobogrammatic Numbers](http://lhearen.top/2016/09/12/Strobogrammatic-Number/)

### Mod of Big Integer
When the result number gets larger and larger in a problem, the final answer always will be the remainder of a big integer (10^9 for example). 

> For example: n^p % m while 1 <= n <= 100, 1 <= p <= 100, m = 10^9+7.

### Solution
There are two formulas to retrieve the remainder of big integers:

 - `(a*b)%m = ((a%m)*(b%m))%m`
 - `(a+b)%m = ((a%m)+(b%m))%m`

#### Recursive
So simply we can come up with a recursive solution as follows:

```
int bigMod(int n, int p, int m){
    if(!p) return 1;
    if(p == 1) return n % m;
    long t = bigMod(n, p>>1, m);
    t = (t * t)%m;
    if(p & 1) return (t * n)%m;
    return t;
}
```

#### Iterative

```
int bigMod(int n, int p, int m){
    long r = n%m, t = 1;
    while(p > 1){
        if(p & 1) t = (t * r)%m;
        r = (r * r)%m;
        p >>= 1;
    }
    return (r * t) % m;
}
```

### Application - Super Pow
Your task is to calculate ab mod 1337 where a is a positive integer and b is an extremely large positive integer given in the form of an array.

> Example1: 
a = 2
b = [3] 
Result: 8

> Example2: 
a = 2
b = [1,0] 
Result: 1024

#### Recursive 

```
class Solution {
    const int base = 1337;
    int powmod(int a, int k) {//a^k mod 1337 where 0 <= k <= 10
        a %= base;
        int result = 1;
        for(int i = 0; i < k; ++i)
            result = (result * a) % base;
        return result;
    }
public:
    int superPow(int a, vector<int>& b) {
        if(b.empty()) return 1;
        int last_digit = b.back();
        b.pop_back();
        return powmod(superPow(a, b), 10) * powmod(a, last_digit) % base;
    }
};
```

#### Iterative

```
class Solution {
private:
    int powMod(int x, int y) {
        int result = 1;
        while (y > 0) {
            if (y & 1) result = (result * x) % 1337;
            y >>= 1;
            x = (x * x) % 1337;
        }
        return result;
    }
public:
    int superPow(int a, vector<int>& b) {
        a %= 1337;
        int result = 1;
        for (int i = 0; i < b.size(); i++) {
            result = (powMod(result, 10) * powMod(a, b[i])) % 1337;
        }
        return result;
    }
};
```

### Integer Break
Given a positive integer n, break it into the sum of at least two positive integers and maximize the product of those integers. Return the maximum product you can get.

> For example, given n = 2, return 1 (2 = 1 + 1); given n = 10, return 36 (10 = 3 + 3 + 4).  Note: You may assume that n is not less than 2 and not larger than 58.


### Solution

#### DP
> **Note** 2-1, 3-2, 4-4, 5-6, 6-9 are all special numbers, excluding these the equation should be `maxArr[i] = max(maxArr[i], j*maxArr[i-1])`

```
int integerBreak(int n) {
	if (n <= 2) return 1;
	vector<int> maxArr(n+1, 0); //maximum of all the possible products;
	maxArr[1] = 0; maxArr[2] = 1; 
	for (int i = 3; i <= n; ++i) 
		for (int j = 1; j < i; ++j) 
			maxArr[i] = max(maxArr[i], max(j*(i-j), j*maxArr[i-j]));
	return maxArr[n];
}
```

#### Math

```
//AC - 0ms - mathematical solution;
//only 2 or 3 will be used to make the product bigger;
//elements bigger than them can be splitted further to make bigger;
//meantime 3*3 > 2*2*2 so we should get as many 3 as possible;
int integerBreak(int n) {
    if(n == 2) return 1;
    if(n == 3) return 2;
    int ret = 1;
    while(n > 4) {
        ret *= 3;
        n -= 3;
    }
    return ret*n;
}
```

```
int integerBreak(int n) 
{
    if(n == 2) return 1;
    if(n == 3) return 2;
    int rest = n % 3;
    int numof3th = n / 3;
    if(rest == 1) { rest  = 4; --numof3th; }
    return pow(3, numof3th) * ((rest == 0) ? 1 : rest);
}
```

### Making Polygons
A polygon is a closed shape with three or more sides. For example, triangles are polygons. A polygon is non-degenerate if it has no overlapping sides (and no sides of zero length).

You have  sticks with positive integer lengths, a0, a1, a2, ..., an-1. You want to create a polygon using all n sticks. Because this is not always possible, you can cut one or more sticks into two smaller sticks (they do not necessarily need to be of integer length) and repeat the process of trying to create a polygon using all the sticks. Given the lengths of all n sticks, find and print the minimum number of cuts necessary to make a non-degenerate polygon.

 > - Input Format 
 > The first line contains a single integer, . 
 > The second line contains  space-separated integers describing the respective values of .
 > 
 > - Constraints 
 > 1<=n<=50
 > 1<=ai<=100
 > 
 > 
 > - Output Format 
 > Print a single integer denoting the minimum number of cuts required to make the  sticks into a polygon.
 > 
 > - Sample Input 0 
 > 3
 > 3 4 5
 > Sample Output 0 
 > 0
 > Explanation 0 
 > We can form a triangle without cutting any of the sticks, so we print  on a new line.
 > 
 > - Sample Input 1 
 > 3
 > 1 2 3
 > Sample Output 1 
 > 1
 > Explanation 1 
 > We can form a  rectangle (convex quadrilateral) by cutting the stick having length  into two sticks having lengths  and . Because this requires one cut, we print  on a new line.

[test](https://www.hackerrank.com/contests/w22/challenges/polygon-making)

### Solution
To using n sticks to form a n-polygon, we have to make sure the sum of all any combination of n-1 sticks is bigger than the remained one. So intuitively we are to select the maximal stick and compare it with the sum of the rest to check its validity.

To retrieve the minimal cuts, we have to make sure each cut is as effective as possible which is the `half cut` (getting the longest evenly partitioned) and then run the logic again until it is no longer degenerate.

```
int main() {
    int n;
    cin >> n;
    vector<int> a(n);
    for(int i = 0; i < n; ++i)
       cin >> a[i];
    int count = 0;
    while(true) {
        int longest = 0, sum = 0;
        for(int i = 0; i < a.size(); ++i) {
            if(a[longest] < a[i]) longest = i;
            sum += a[i];
        }
        sum -= a[longest];
        if(sum > a[longest]) break;
        a.insert(a.begin()+longest, a[longest]/2);
        a.insert(a.begin()+longest, (a[longest]+1)/2);
        a.erase(a.begin()+longest+2);
        count++;
    }
    cout<<count<<endl;
    return 0;
}
```

### Expression Add Operators
Given a string that contains only digits 0-9 and a target value, return all possibilities to add binary operators (not unary) +, -, or * between the digits so they evaluate to the target value.

> Examples: 
> "123", 6 -> ["1+2+3", "1\*2\*3"] 
> "232", 8 -> ["2\*3+2", "2+3\*2"]
> "105", 5 -> ["1\*0+5","10-5"]
> "00", 0 -> ["0+0", "0-0", "0\*0"]
> "3456237490", 9191 -> []

[test](https://leetcode.com/problems/expression-add-operators/)

### Solution

#### Analysis
Typical backtracking problem as it is. Try to split the string into small blocks and then meantime try different operators among them.

- from a starting position, we can try different valid lengths for the current number but if the length is bigger than 1 and the first digit is zero then just stop;
- using different operators to connect the current number, calculate and then store them in a temporary string for the next number till the end;
- but when we try `*`, we have to be more careful since multiplier will associate its previous number and has higher precedence, so we as a result have to record its previous number; but this will require us to handle it delicately when we are inserting `+ or -`, as for `+` we can just put the number as previous but as to `-`, we will need to set `-number` as previous; because we have to subtract the previous number first when inserting `*` - inserting means we are do the calculation with the current number here;
- since the target is an `int`, so when the number is larger than INT_MAX, we should just top there.

#### Improvements
- there will be numbers collected larger than INT_MAX, so we have to adopt `long` - long long here is unnecessary;
- collecting the number one character at a time is more efficient to convert the substring directly to integer using `stol`;
- using temporary substring to replace `to_string(number)` will save lots of converting time;
- actually we can just use one temporary string and append the digit instead of retrieving the substring each time.

The whole solution in C++ is as follows.

```
class Solution {
private:
    int sLen;
    void traverse(const string s, int pos, long current, long pre, int sum, string path, vector<string>& v) {
        if(sLen == pos) { if(current == sum) v.push_back(path); return ; }
        long num = 0;
        string t;
        for(int i = pos; i < sLen; ++i) {
            if(i-pos>0 && s[pos]=='0') return ;
            t += s[i];
            num = 10*num + s[i]-'0';
            if(num > INT_MAX) return ;
            if(pos == 0) traverse(s, i+1, num, num, sum, t, v);
            else {
                traverse(s, i+1, current+num, num, sum, path+"+"+t, v);
                traverse(s, i+1, current-num, -num, sum, path+"-"+t, v);
                traverse(s, i+1, current-pre+pre*num, pre*num, sum, path+"*"+t, v);
            }
        }
    }
public:
    vector<string> addOperators(string s, int target) {
        sLen = s.length();
        vector<string> v;
        traverse(s, 0, 0, 0, target, "", v);
        return v;
    }
};
```

### Description
Given two numbers represented as strings, return multiplication of the numbers as a string.
> Note:
The numbers can be arbitrarily large and are non-negative.
Converting the input string to integer is NOT allowed.
You should NOT use internal library such as BigInteger.

[test](https://leetcode.com/problems/multiply-strings/)

### Solution
In fact before we truly hack this problem, we might remember other calculations for [linked list][1] and [binary strings][2] and trying to reuse that kind of pattern; but soon we will find out that will cost much energy and time to solve this one: multiply for each digits, move one step for the next digit and then add them, so annoying and tedious.

So we will try another naive one to easily hack this, imitating the multiplication process we human do but convert it a little bit for easier latter work.  The following steps will use 34 * 56 to present the whole process:

 - first, we multiply the lowest digit 6 with all the first number 34 without any carry just store the numbers: 18, 24 - from left to right respectively (all the carry operations will be handled in the following steps); then the second lowest digit 5 and the result numbers will be 15, 20 from left to right respectively;
 - second, actually when we human calculate, (15, 20) as a whole will be moved to the left by one digit, right? Why? Because digit 5 is left-er than the digit 6 by one digit; okay, things are now getting clearer now; here we are going to use an array to store the result of each *position* , still ignoring carry here; one thing should be remembered is that the position is determined by the position of the digit in both the first and second number; if you know how the multiplication process, then this will be easy to understand.
 - third, we are almost there; strings are indexed from left to right, so the smaller the index of the digit the higher its digit base (100, 10, 1 etc) will be; so we will store the results following this fact, from left to right, the unit will be decreasing; as we have discussed in second part, the position will be determined by that of digits in both first and second number so arr[i+j] = (num1[i]-'0')\*(num2[j]-'0') will be a good equation; but the same position might be used to store several results from different pairs of digits multiplication. So `arr[i+j] += (num1[i]-'0')*(num2[j]-'0')` and before we collect the results, we have to initialise all elements of arr to zero. 
 - fourth, collecting the result and constructing the result string to return: from the last to the first we get carried by `a[i-1] = a[i]/10; a[i] %= 10;`.

--------
 - Space cost O(n)
 - Time cost O(n)

```
class Solution {
public:
    //AC - 8ms - careful about the corner cases;
    string multiply(string num1, string num2) {
        string s;
        vector<int> v(num1.size()+num2.size()-1, 0);
        for(int i = num1.size()-1; i >= 0; --i)
			for(int j = num2.size()-1; j >= 0; --j)
				v[i+j] += (num1[i]-'0') * (num2[j]-'0');
        for(int i = v.size()-1; i > 0; --i) {
            v[i-1] += v[i] / 10;
            v[i] %= 10;
        }
        if(v[0] == 0) return "0"; //started with '0', it must be zero;
        if(v[0] / 10) {//there is still a carrier to be collected;
            s += to_string(v[0]/10);
            v[0] %= 10;
        }
        for(int i = 0; i < v.size(); ++i) s += to_string(v[i]);
        return s;
    }
};
```

### Description
There are n bulbs that are initially off. You first turn on all the bulbs. Then, you turn off every second bulb. On the third round, you toggle every third bulb (turning on if it's off or turning off if it's on). For the ith round, you toggle every i bulb. For the nth round, you only toggle the last bulb. Find how many bulbs are on after n rounds.

> Example: 
Given n = 3.  
At first, the three bulbs are [off, off, off].
After first round, the three bulbs are [on, on, on].
After second round, the three bulbs are [on, off, on].
After third round, the three bulbs are [on, off, off].  
So you should return 1, because there is only one bulb is on.

[test](https://leetcode.com/problems/bulb-switcher/)

### Solution
Before we take a jump to the solution, let's first try to clear out what exactly the problem is talking about: 
 - every i-th distance you switch the bulb to the opposite state (from on to off, or from off to on); actually suppose the bulbs are labelled from 1 to n then the every second bulb will mean that 2, 4, 6, 8, ... all even numbers less than n; while every third bulb will be 3, 6, 9, 12, ... all multiples of 3 that is less than n and so on; 
 - since the bulb will only have two different states - on or off, the result will be quite clear now; odd switching operations will result in bulb-on state (since original state is bulb-off) while even switching operations will give us bulb-off state;

Now the purpose here is clear searching for the **odd-operation numbers**: 
 - as for primes, they only have 1 and itself as their factors, even-operation numbers;
 - as for non-primes, normally they will have different pairs of factors like 12 whose factors are (1, 12), (3, 4), (2, 6) - 6 different factors, also even-operation numbers;
 - but among non-primes, there are some special numbers, perfect square numbers like 9 whose factors are (1, 9) and (3, 3) - odd-operation numbers, which means there will be only three different numbers that will affect the current bulb and result in bulb-on state!

So that's all we need to know to hack this problem now. But how to get the amount of squares that are less than n, quite simple. Sqrt(n) is the answer, since all square numbers that is less than n will be 1, 4, 9 ... n and their corresponding square roots will be 1, 2, 3,... sqrt(n).

 - Space cost O(1)
 - Time cost O(1)

```
//AC - 0ms;
int bulbSwitch(int n) {
	return sqrt(n);
}
```

### General
It's always tricky to solve a math problem especially something difficult which might require sophisticated understanding of mathematics including *permutation and combination*, *probability theory* and even *digital logic design* and the like. However, using math can always solve problems in a very efficient and clean way, so do not hesitate to dive into this. We will go through this topic in a practical way, checking examples as many as possible.

### Examples
All techniques are in the examples shown below which all in C++, enjoy the journey.

#### Water and Jug Problem
You are given two jugs with capacities x and y litres. There is an infinite amount of water supply available. You need to determine whether it is possible to measure exactly z litres using these two jugs.
If z liters of water is measurable, you must have z liters of water contained within one or both buckets by the end.
Operations allowed:
 - Fill any of the jugs completely with water.
 - Empty any of the jugs.
 - Pour water from one jug into another till the other jug is completely full or the first jug itself is empty.
```
class Solution {
private:
    int gcd(int a, int b) {
        return b? gcd(b, a%b):a;
    }
public:
    bool canMeasureWater(int x, int y, int z) {
        //constraint 3
        if(x+y < z) return false;
        //in case of zero
        if(x==z || y==z) return true;
        //Bezout's identity - xa+yb=d 
        //(-1*3+2*5=4, negative means pouring out, positive means filling up)
        return z%gcd(x, y) == 0;
    }
};
```
#### Sqrt implementation
Binary search method
```
int sqrt(int num) {
    long l = 0, r = num, m = 0;
    while(l < r) {
        m = l+(r-l)/2;
        if(m*m < num) l = m+1;
        else r = m;
    }
    return r;
}
```
Newton method
```
int sqrt(int num) {
    long g = num;
    while(g*g > num) g = (g+num/g)>>1;
}
```
#### Count Numbers with Unique Digits
Given a non-negative integer n, count all numbers with unique digits, x, where 0 ≤ x < 10n.
Example:
Given n = 2, return 91. (The answer should be the total numbers in the range of 0 ≤ x < 100, excluding [11,22,33,44,55,66,77,88,99]). 
```
//(1-digit 10,  2-digit 91 = 9*9+10, 3-digit 739=9*9*8+9*9+10)
int countNumbersWithUniqueDigits(int n) {
    if(n == 0) return 1;
    int sum = 10;
    for(int i = 2; i <= n; ++i) {
        int t = 9;
        for(int j = 0; j < i-1; ++j) t *= (9-j);
        sum += t;
    }
    return sum;
}
```
#### Power of Three
Quite simple problem but there are ways of doing this. (recursive, iterative, map-checking and math, pow and log are often used)
```
bool isPowerOfThree(int n) {
    return n>0 && 1162261467%n==0;
}
```
#### Super Ugly Number
Write a program to find the nth super ugly number.  Super ugly numbers are positive numbers whose all prime factors are in the given prime list primes of size k. For example, [1, 2, 4, 7, 8, 13, 14, 16, 19, 26, 28, 32] is the sequence of the first 12 super ugly numbers given primes = [2, 7, 13, 19] of size 4.
Note:
(1) 1 is a super ugly number for any given primes.
(2) The given numbers in primes are in ascending order.
(3) 0 < k ≤ 100, 0 < n ≤ 106, 0 < primes[i] < 1000.
```
int nthSuperUglyNumber(int n, vector<int>& primes) {
    int size = primes.size();
    int indexes[size]{0}; //follow its corresponding index always;
    vector<int> v(1,1);
    for(int i = 1; i < n; ++i) {
        int localMin = INT_MAX;
        for(int j = 0; j < size; ++j)
            localMin = min(localMin, primes[j]*v[indexes[j]]);
        v.push_back(localMin);
        for(int j = 0; j < size; ++j) //follow its corresponding index always;
            if(localMin == primes[j]*v[indexes[j]]) indexes[j]++;
    }
    return v.back();
}
```
#### Integer to English Words
Convert a non-negative integer to its english words representation. Given input is guaranteed to be less than 231 - 1.
For example,
123 -> "One Hundred Twenty Three"
12345 -> "Twelve Thousand Three Hundred Forty Five"
1234567 -> "One Million Two Hundred Thirty Four Thousand Five Hundred Sixty Seven"
```
class Solution {
    const vector<string> numerals{"Billion", "Million", "Thousand", "Hundred", "Ninety","Eighty", "Seventy","Sixty", "Fifty", "Forty", "Thirty", "Twenty", "Nineteen", "Eighteen", "Seventeen", "Sixteen", "Fifteen", "Fourteen", "Thirteen", "Twelve","Eleven", "Ten","Nine", "Eight", "Seven", "Six", "Five", "Four", "Three","Two", "One"};
    const vector<int> units = {1000000000, 1000000, 1000, 100, 90, 80, 70, 60,50, 40,30,20,19, 18, 17, 16,15,14,13,12,11,10,9,8,7,6,5,4,3,2,1};
public:
    string numberToWords(int num) {
        if(num == 0) return "Zero";
        int i = 0;
        for(; num < units[i]; ++i) ;
        int upper = num/units[i];
        int lower = num%units[i];
        return (i<4? numberToWords(upper) + " " : "") + numerals[i] + (lower? " " + numberToWords(lower) : "");
    }
};
```
#### Add Digits
Given a non-negative integer num, repeatedly add all its digits until the result has only one digit.
> For example: 
Given num = 38, the process is like: 3 + 8 = 11, 1 + 1 = 2. Since 2 has only one digit, return it.  
Follow up: Could you do it without any loop/recursion in O(1) runtime?

##### Basic
```
int addDigits(int num) {
	int sum = num;
	while(sum >= 10){
		num = sum;
		sum = 0;
		while(num){
			sum += num%10;
			num /= 10;
		}
	}
	return sum;
}
```
##### Trick
```
int addDigits(int num) {
    return num? (num%9? num%9:9) : num;
}
```
#### Number of Digit One 
Given an integer n, count the total number of digit 1 appearing in all non-negative integers less than or equal to n.
For example:
Given n = 13,
Return 6, because digit 1 occurred in the following numbers: 1, 10, 11, 12, 13.
```
//permutation and combination problem;
int countDigitOne(int n) {
    int sum = 0;
    for(long i = 1; i <= n; i *= 10) {
        int a = n/i;
        int b = n%i;
        sum += (a+8)/10*i+(a%10==1? b+1 : 0);
    }
    return sum;
}
```
#### Basic Calculator    
Implement a basic calculator to evaluate a simple expression string.  
The expression string may contain open ( and closing parentheses  ), the plus + or minus sign -, non-negative integers and empty spaces .
You may assume that the given expression is always valid.
Some examples:
"1 + 1" = 2
" 2-1 + 2 " = 3
"(1+(4+5+2)-3)+(6+8)" = 23

##### Iterative method
```
int calculate(string s) {
    stack<int> sums, signs;
    int sum = 0, sign = 1, num = 0;;
    for(int i = 0; s[i]; ++i) {
        if(isdigit(s[i])) num = 10*num+s[i]-'0';
        else {
            sum += sign*num;
            num = 0;
            if(s[i]=='+' || s[i]==' ') sign = 1;
            else if(s[i] == '-') sign = -1;
            else if(s[i] == '(') { sums.push(sum), signs.push(sign); sum = 0, sign = 1; }
            else if(s[i] == ')') { sum = sums.top()+sum*signs.top(); sums.pop(), signs.pop(); }
        }
    }
    return sum+sign*num;
}
```
##### Recursive method
```
class Solution {
private:
    int calculate(string& s, int& pos) {//reference to pos tracking the index;
        int sum = 0;
        int sign = 1;
        while(pos<s.length() && s[pos]!=')') {
            if(s[pos]=='+' || s[pos]==' ') pos++, sign = 1;
            else if(s[pos] == '-') pos++, sign = -1;
            else if(s[pos] == '(') { pos++; sum += sign*calculate(s, pos); }
            else {
                int num = 0;
                while(isdigit(s[pos])) num = 10*num + s[pos++]-'0';
                sum += sign*num; 
            }
        }
        pos++; //move over the ')';
        return sum;
    }
public:
    int calculate(string s) {
        int pos = 0;
        return calculate(s, pos);
    }
};
```
#### Rectangle Area
Find the total area covered by two rectilinear rectangles in a 2D plane.
Each rectangle is defined by its bottom left corner and top right corner as shown in the figure.
Rectangle Area
Assume that the total area is never beyond the maximum possible value of int.
```
int computeArea(int A, int B, int C, int D, int E, int F, int G, int H) {
    int lMax = max(A, E), rMin = min(C, G), bMax = max(B, F), tMin = min(D, H);
    return (D-B)*(C-A)+(G-E)*(H-F) - ((B>H || F>D || E>C || A>G)? 0 : (rMin-lMax)*(tMin-bMax));
}
```
#### Factorial Trailing Zeroes
Given an integer n, return the number of trailing zeroes in n!.
Note: Your solution should be in logarithmic time complexity.
```
int trailingZeroes(int n) {
    int count = 0;
    for(long i = 5; i <= n; i *= 5)
        count += n/i;
    return count;
}
```
#### Happy Number
Write an algorithm to determine if a number is "happy".
A happy number is a number defined by the following process: Starting with any positive integer, replace the number by the sum of the squares of its digits, and repeat the process until the number equals 1 (where it will stay), or it loops endlessly in a cycle which does not include 1. Those numbers for which this process ends in 1 are happy numbers.  
> Example: 19 is a happy number
12 + 92 = 82
82 + 22 = 68
62 + 82 = 100
12 + 02 + 02 = 1

##### Basic
```
class Solution {
private:
    int square(int n) {
        int a = 0;
        while(n) {
            a += (n%10)*(n%10);
            n /= 10;
        }
        return a;
    }
public:
    bool isHappy(int n) {
        int slow = square(n), fast = square(square(n));
        while(slow != fast) {
            slow = square(slow);
            fast = square(square(fast));
        }
        return slow == 1;
    }
};
```

##### Trick
```
//in [0, 9] there are only 1 and 7 that are happy numbers;
int isHappy(int n)
{
    while(n > 6) {//once it's less than 6 and if it's not 1, it must be unhappy number;
        int next = 0;
        while(n) {//calculate the square sum;
            next += (n%10)*(n%10);
            n /= 10;
        }
        n = next;
    }
    return n == 1;
}
```

#### Count Primes
Count the number of prime numbers less than a non-negative number, n.

##### Basic method
```
int countPrimes(int n) {
    if(n < 3) return 0;
    vector<bool> numbers(n, true);
    numbers[0] = numbers[1] = false;
    for(int i = 2; i <= sqrt(n); i++)
        for(int j = i*i; j < n; j += i)
            if(numbers[j]) numbers[j] = false;
    int count = 0;
    for(auto i: numbers)
        if(i) count++;
    return count;
}
```
##### Optimized method
```
int countPrimes(int n) {
    if(!n || n==1) return 0;
    bool *numbers = new bool[n];
    memset(numbers, 1, sizeof(bool)*n);
    int count = n/2; //only odd numbers should be considered;
    for(int i = 3; i <= sqrt(n); i += 2) {
        if(numbers[i]) {
            for(int j = i*i, k = i<<1; j < n; j += k) {  
                if(numbers[j]) count--;
                numbers[j] = false;
            }
        }
    }
    return count;
}
```

#### Excel Sheet Column Title
Given a positive integer, return its corresponding column title as appear in an Excel sheet.
> For example: 1 -> A 2 -> B 3 -> C ...  26 -> Z 27 -> AA 28 -> AB 

##### Iterative
```
string convertToTitle(int n) {
    string s;
    while(n) {
        s = string(1, 'A'+(n-1)%26) + s; //make it start from 0 instead of 1
        n = (n-1)/26;
    }
    return s;
}
```
##### Recursive
```
string convertToTitle(int n) {
    return ((n-1)/26? convertToTitle((n-1)/26) : "") + string(1, 'A'+(n-1)%26);   
}
```

#### Fraction to Recurring Decimal
Given two integers representing the numerator and denominator of a fraction, return the fraction in string format.  If the fractional part is repeating, enclose the repeating part in parentheses.
For example, 
Given numerator = 1, denominator = 2, return "0.5".
Given numerator = 2, denominator = 1, return "2".
Given numerator = 2, denominator = 3, return "0.(6)".
Imitating the division process is the key.
```
string fractionToDecimal(int n, int d) {
    string s;
    int i = 0;
    if(!n) return "0";
    if(n<0 ^ d<0) s += "-";
    long numerator = fabs(long(n)), denominator = fabs(long(d));
    s += to_string(numerator/denominator);
    numerator %= denominator;
    if(numerator) s += ".";
    unordered_map<int, int> pos_map;
    i = s.length()-1;
    while(numerator) {
        if(pos_map.count(numerator)) {
            s.insert(pos_map[numerator], "(");
            s += ")";
            break;
        }
        pos_map[numerator] = ++i;
        numerator *= 10;
        s += to_string(numerator/denominator);
        numerator %= denominator;
    }
    return s;
}
```

#### String to Integer (atoi)
Implement atoi to convert a string to an integer.
Hint: Carefully consider all possible input cases. If you want a challenge, please do not see below and ask yourself what are the possible input cases.
Notes: It is intended for this problem to be specified vaguely (ie, no given input specs). You are responsible to gather all the input requirements up front.
```
int myAtoi(string str) {
    int i = 0;
    int sign = 1;
    long num = 0;
    while(isspace(str[i])) i++;
    if(str[i]=='-' || str[i]=='+') {
        if(str[i] == '-') sign *= -1;
        i++;
    }
    while(str[i]=='0') i++;
    while(isdigit(str[i])) {
        num = 10*num + str[i++]-'0';
        if(num > fabs(long(INT_MIN))) break;
    }
    num *= sign;
    if(num < INT_MIN) return INT_MIN;
    if(num > INT_MAX) return INT_MAX;
    return num;
}
```

#### Integer to Roman
Given an integer, convert it to a roman numeral.
Input is guaranteed to be within the range from 1 to 3999.
##### Basic
```
string intToRoman(int num) {
	string s, table[] = {"M", "CM", "D", "CD", "C", "XC", "L", "XL", "X", "IX", "V", "IV", "I"};
	int units[] = {1000, 900, 500, 400, 100, 90, 50, 40, 10, 9, 5, 4, 1};
	for(int i = 0; i < sizeof(units)/sizeof(int); ++i) {
		while(num >= units[i]) {
			s += table[i];
			num -= units[i];
		}
	}
	return s;
}
```

##### Mapping

```
string intToRoman(int num) {
	string s;
	string M[] = {"", "M", "MM", "MMM"};
	string C[] = {"", "C", "CC", "CCC", "CD", "D", "DC", "DCC", "DCCC", "CM"};
	string X[] = {"", "X", "XX", "XXX", "XL", "L", "LX", "LXX", "LXXX", "XC"};
	string I[] = {"", "I", "II", "III", "IV", "V", "VI", "VII", "VIII", "IX"};
	s += M[num/1000];
	s += C[(num%=1000)/100];
	s += X[(num%=100)/10];
	s += I[(num%10)];
	return s;
}
```

#### Roman to Integer

```
class Solution {
public:
    //AC - 60ms - from left to right using unordered_map;
    int romanToInt(string s) {
        unordered_map<char, int> roman_map { { 'I' , 1  },{ 'V' , 5  },{ 'X' , 10  }, 
            { 'L' , 50  }, { 'C' , 100  }, { 'D' , 500  }, { 'M' , 1000  }  };
        int pre = 1, cur = 1, sum = 0;
        for(int i = s.length()-1; i >= 0; --i) {
            cur = roman_map[s[i]];
            if(cur < pre) sum -= cur;
            else sum += cur, pre = cur;
        }
        return sum;
    }
    //AC - 36ms - from right to left and using array to accelerate searching;
    int romanToInt(string s) {
        if (s.empty()) return 0;
        int roman_map[24] = {};
        roman_map['I' - 'A'] = 1;
        roman_map['V' - 'A'] = 5;
        roman_map['X' - 'A'] = 10;
        roman_map['L' - 'A'] = 50;
        roman_map['C' - 'A'] = 100;
        roman_map['D' - 'A'] = 500;
        roman_map['M' - 'A'] = 1000;

        auto sum = 0;
        auto right = roman_map[s.front() - 'A'];
        for (int i = 1; i < s.size(); ++i) {
            auto curr = right;
            right = roman_map[s[i] - 'A'];
            if (right > curr) sum -= curr;
            else sum += curr;
        }
        return sum + right;
    }
};
```

#### Divide Two Integers
Divide two integers without using multiplication, division and mod operator.
If it is overflow, return MAX_INT. Similar problem - sqrt(x).

Bit manipulation actually
```
int divide(int dividend, int divisor) {
    if((dividend==INT_MIN && divisor==-1) || divisor==0) return INT_MAX;
    int sign = (dividend<0 ^ divisor<0)? -1 : 1;
    long dd = abs((long)dividend), dv = abs((long)divisor);
    if(dd < dv) return 0;
    int h = 0;
    long t = dv;
    while(t <= dd) t <<= 1, h++;
    long ret = 1 << --h;
    dd -= (t>>=1);
    while(dd >= dv) {
        while(t > dd)
            t >>= 1, h--;
        ret |= 1<<h;
        dd -= t;
    }
    return ret*sign;
}
```

Trick using div, still log can also do the same
```
int divide(int dividend, int divisor) {
    if(dividend==INT_MIN && divisor==-1) return INT_MAX;
    div_t divresult = div(dividend, divisor);
    return divresult.quot;
}
```

#### Add Binary
Given two binary strings, return their sum (also a binary string).
For example,
a = "11"
b = "1"
Return "100".

```
string addBinary(string a, string b) {
    string s;
    int i = a.length()-1, j = b.length()-1, c = 0;
    while(i>=0 || j>=0) {
        c += i>=0? a[i--]-'0':0;
        c += j>=0? b[j--]-'0':0;
        s = char(c%2+'0') + s;
        c /= 2;
    }
    return c? "1"+s : s;
}
```

#### Palindrome Number
Determine whether an integer is a palindrome. Do this without extra space.

##### Basic
```
bool isPalindrome(int x) {
	if(x < 0) return false;
	long a = 0, t = x;
	while(t) {
		a = 10*a + t%10;
		t /= 10;
	}
	return a == x;
}
```
##### Trick
```
bool isPalindrome(int x) {
	if(x<0 || (x>0 && x%10==0)) return false;
	int a = 0;
	while(a < x) {
		a = 10*a + x%10;
		x /= 10;
	}
	return a>x? a/10==x : a==x;
}
```

#### Valid Number 
Validate if a given string is numeric.
Some examples:
"0" => true
" 0.1 " => true
"abc" => false
"1 a" => false
"2e10" => true

```
bool isNumber(string s) {
    int i = 0, digit_count = 0, dot_count = 0;
    while(s[i] == ' ') i++;
    if(s[i]=='+' || s[i]=='-') i++;
    while(isdigit(s[i]) || s[i]=='.') s[i++]=='.'? dot_count++ : digit_count++;
    if(dot_count>1 || digit_count<1) return false;
    if(s[i] == 'e') {
        i++;
        dot_count = digit_count = 0;
        if(s[i]=='+' || s[i]=='-') i++;
        while(isdigit(s[i]) || s[i]=='.') s[i++]=='.'? dot_count++ : digit_count++;
        if(dot_count>0 || digit_count<1) return false;
    }
    while(s[i] == ' ') i++;
    return s[i] == '\0';
}
```

Use `strtof` to handle float format as a trick

```
bool isNumber(string s) {
    char *pEnd, *str = (char*)s.c_str();
    while(*str == ' ') str++;
    if(*str == '\0') return false;
    float f = strtof(str, &pEnd);
    //Reference to an already allocated object of type char*, 
    //whose value is set by the function to the next character 
    //in str after the numerical value.
    while(*pEnd == ' ') pEnd++;
    return *pEnd == '\0';
}
```

#### Pow(x, n)
Implement pow(x, n).
##### Iterative
```
double myPow(double x, int m) {
    long n = m;
    if(n == 0) return 1;
    if(n < 0) n *= -1, x = 1/x;
    double unit = x, ret = 1;
    while(n) {
        if(n & 1) ret *= unit;
        unit *= unit; //updated each time;
        n >>= 1;
    }
    return ret;
}
```
##### Recursive
```
double myPow(double x, int m) {
    long n = m; //in case of INT_MIN;
    if(n < 0) x = 1/x, n *= -1;
    if(n == 0) return 1;
    if(n == 1) return x;
    return n%2? x*myPow(x*x, n/2) : myPow(x*x, n/2);
}
```

#### Permutation Sequence 
The set [1,2,3,…,n] contains a total of n! unique permutations.
By listing and labeling all of the permutations in order,
We get the following sequence (ie, for n = 3):
"123"
"132"
"213"
"231"
"312"
"321"
Given n and k, return the kth permutation sequence.

```
string getPermutation(int n, int k) 
{
    int i = 1, j = 0, p = 1;
    string s;
    for(; i <= n; ++i)
    {
        p *= i;
        s += char('0'+i);
    }
    for(i = 0, k--; i < n; ++i)
    {
        p /= n-i;
        j = i + k/p;
        char c = s[j];
        for(; j > i; --j) s[j] = s[j-1];
        s[i] = c;
        k %= p;
    }
    return s;
}
```

#### Max Points on a Line
Given n points on a 2D plane, find the maximum number of points that lie on the same straight line.

```
int maxPoints(vector<Point>& points) {
    int globalMax = 0, duplicates = 1;
    unordered_map<double, int> slopes;
    for(int i = 0; i < points.size(); ++i) {
        slopes.clear();
        duplicates = 1;
        for(int j = i+1; j < points.size(); ++j) {
            if(points[i].x==points[j].x && points[i].y==points[j].y) duplicates++;
            else {
                if(points[i].x==points[j].x) slopes[INT_MAX]++;
                else slopes[(double)(points[j].y-points[i].y)/(points[j].x-points[i].x)]++;
            }
        }
        int localMax = 0;
        for(auto& pair: slopes) localMax = max(pair.second, localMax);
        globalMax = max(globalMax, localMax+duplicates);
    }
    return globalMax;
}
```

#### Finding nth Finobacci number in O(log n)
Finding the nth Fibonacci number using dynamic programming runs in O(n) time. There is still a better method to find F(n), when n become as large as 10^18 (as F(n) can be very huge, all we want is to find the F(N)%MOD , for a given MOD).  Consider the Fibonacci recurrence F(n+1) = F(n) + F(n-1). We can represent this in the form a matrix here. ![matrix](/images/fibonacci.png)
Look at the matrix A = [  [ 1 1  ]  [ 1 0  ]   ] . Multiplying A with [ F(n)  F(n-1)  ] gives us [ F(n+1)  F(n)  ] , so.. We start with [ F(1)  F(0)  ] , multiplying it with An gives us [ F(n+1)  F(n)  ] , so all that is left is finding the nth power of the matrix A. Well, this can be computed in O(log n) time, by recursive doubling. The idea is, to find An , we can do R = An/2 x An/2 and if n is odd, we need do multiply with an A at the end. 

```
Matrix findNthPower(Matrix M , power n) {
    if( n == 1  )  return M;
    Matrix R = findNthPower(M , n/2);
    R = RxR;  // matrix multiplication
    if(n%2 == 1) R = RxM;  // matrix multiplication
    return R;
}
```

#### Combinatorics
Another problem might also encounter big integer is to select k gifts from n, normally we could achieve an efficient solution as follows.

```
unsigned long long choose(unsigned long long n, unsigned long long k) {
    if (k > n) return 0;
    unsigned long long r = 1;
    for (unsigned long long d = 1; d <= k; ++d) {
        r *= n--;
        r /= d;
    }
    return r;
}
```

### Integer Replacement
Given a positive integer n and you can do operations as follow: 
- If n is even, replace n with n/2.
- If n is odd, you can replace n with either n + 1 or n - 1.
- What is the minimum number of replacements needed for n to become 1?

> Example 1: 
Input: 8 
Output: 3 
Explanation: 8 -> 4 -> 2 -> 1

> Example 2: 
Input: 7
Output: 4 
Explanation: 7 -> 8 -> 4 -> 2 -> 1 or 7 -> 6 -> 3 -> 2 -> 1

[test](https://leetcode.com/problems/integer-replacement/)

### Solution
Explanation will be added.

```
class Solution {
    unordered_map<long, int> count_map;
public:
    int replace(long n, long upper){
        if(n <= 1) return 0;
        if(n > upper) return n;
        if(count_map.count(n)) return count_map[n];
        if(n%2 == 0) return count_map[n] = replace(n/2, upper)+1;
        else return count_map[n] = min(replace(n-1, upper), replace(n+1, upper))+1;
    }
    int integerReplacement(int n) {
        return replace((long)n, (long)n*2);
    }
};
```

### Description
A strobogrammatic number is a number that looks the same when rotated 180 degrees (looked at upside down).  Write a function to determine if a number is strobogrammatic. The number is represented as a string.  
> For example, the numbers "69", "88", and "818" are all strobogrammatic.

> Follow-up: Find all strobogrammatic numbers that are of length = n.  For example, Given n = 2, return ["11","69","88","96"].


### Solution
Explanation will be added.
[test](https://leetcode.com/problems/strobogrammatic-number/)

#### Extra space
```
bool isStrobogrammatic(string s) {
	if(s.empty()) return true;
	int len = s.length();
	if(len > 1 && s[len-1]=='0') return false;
	for(int i = 0; i < len; ++i) if(!(s[i]=='0' || s[i]=='1' || s[i]=='8' || s[i]=='6' || s[i]=='9')) return false;
	string t(s.rbegin(), s.rend());
	for(int i = 0; i < len; ++i){
		if(t[i] == '6') t[i] = '9';
		else if(t[i] == '9') t[i] = '6';
	}
	return t==s;
}
```
#### Without extra space
```
bool isStrobogrammatic(string num) {
	for(int i=0;i<=(num.size()-1)/2;i++){
		if(num[i] == '1' && num[num.size()-1-i] == '1') continue;
		if(num[i] == '8' && num[num.size()-1-i] == '8') continue;
		if(num[i] == '0' && num[num.size()-1-i] == '0') continue;
		if(num[i] == '6' && num[num.size()-1-i] == '9') continue;
		if(num[i] == '9' && num[num.size()-1-i] == '6') continue;
		return false;
	}
	return true;
}
```

#### Follow-1
[test](https://leetcode.com/problems/strobogrammatic-number-ii/)
##### Intuitive
```
class Solution {
    void traverse(int pos, int k, bool odd, char candidates[5], string num, vector<string>& v){
        if(pos == k) { 
            if(odd) { v.push_back(num+'0'); v.push_back(num+'1'); v.push_back(num+'8'); }
            else v.push_back(num); 
            return ;
        }
        if(pos < k) {
            for(int i = 0; i < 5; ++i){
                if(pos==0 && i==0) continue;
                num += candidates[i];
                traverse(pos+1, k, odd, candidates, num, v);
                num.pop_back();
            }
        }
    }
public:
    vector<string> findStrobogrammatic(int n) {
        char candidates[5]{'0', '1', '6', '8', '9'};
        vector<string> v;
        if(n == 1) return vector<string>{"0", "1", "8"};
        traverse(0, n/2, n%2, candidates, "", v);
        for(string& s: v){
            for(int i = n/2-1; i >= 0; --i){
                if(s[i] == '1') s += '1';
                else if(s[i] == '0') s += '0';
                else if(s[i] == '8') s += '8';
                else if(s[i] == '6') s += '9';
                else if(s[i] == '9') s += '6';
            }
        }
        return v;
    }
};
```

##### Trick

```
class Solution {
    vector<int> first = {0, 1, 6, 8, 9}, second = {0, 1, 9, 8, 6};
public:
    vector<string> findStrobogrammatic(int n) {
        vector<string> res;
        string s (n, '0');
        helper(res, s, 0, s.size() / 2);
        return res;
    }
    
    void helper(vector<string>& res, string& s, int digit_start, int upper_border) {
        if (digit_start == upper_border) {
            res.push_back(s);
            if (s.size() == digit_start * 2) return;
            s[digit_start] = '1';
            res.push_back(s);
            s[digit_start] = '8';
            res.push_back(s);
            s[digit_start] = '0';
            return;
        }
        
        int mask_start = (digit_start == 0) ? 1 : 0;  
        for (int j = mask_start; j < 5; j ++) {
            s[digit_start] += first[j];
            s[s.size() - 1 - digit_start] += second[j];
            helper(res, s, digit_start + 1, upper_border);
            s[digit_start] -= first[j];
            s[s.size() - 1 - digit_start] -= second[j];
        }
    }
};
```
